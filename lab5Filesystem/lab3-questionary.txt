=== This template file contains questions you need to answer.
=== Fill your answers on appropriate blank lines only.
=== Don't start any line with three equal signs "===".
=== Don't edit any lines starting from three equal signs.
=== Use C notation to write numbers: 42 for decimal, 0x2a for hexadecimal.
=== We may check most of the answers automatically, so "forty two" or
=== "26+16" won't work for this example. Spaces are mostly ignored, so
=== "  42  " is OK (without quotes of course). 
=== When asked to specify address & instruction, do it in the form of
=== gdb output "ADDRESS: INSTRUCTION", for example "0x7c26:  or  $0x1,%eax"
=== Don't make lines longer than 80 characters. You don't need to fit your
=== answer in a single line, you can start a new line at will.
=== However, when asked to fill "a table" make each table raw a single line.

=== Q In Exercise 4, can the function 'trap' ever return?
===   (yes/no)
no

=== Q What is the purpose of having an individual handler function for
===   each exception/interrupt? (i.e., if all exceptions/interrupts
===   were delivered to the same handler, what feature that exists in
===   the current implementation could not be provided?)
===   (free form, 1 sentence)
Different exceptions/interrupts require different handling, having individual
handlers makes it possible to deal with each appropriately, so Without this
separation, we couldn't easily implement protections or specific behaviors for
each case.

=== Q Did you have to do anything to make the user/softint program
===   behave correctly?
===   (yes/no)
yes

=== Q The grade script expects it to produce a general protection
===   fault (trap 13), but softint's code says int $14. Why should
===   this produce interrupt vector 13? 
===   (free form, 1 sentence)
Because the int $14 instruction causes a privilege violation when executed in
user mode (CPL = 3) since the interrupt DPL is 0 (kernel mode), leading to 
a general protection fault (trap 13) to protect the system.

=== Q What happens if the kernel actually allows softint's int $14
===   instruction to invoke the kernel's page fault handler (which is
===   interrupt vector 14)?
===   (free form, 1 sentence)
Since page faults are exceptions generated by the CPU, allowing user code to
invoke them (allows int $14) could enable the user to fake page faults,
potentially bypassing security checks or corrupting system behavior like
memory management.

=== Q The break point test case will either generate a break point
===   exception or a general protection fault depending on how you
===   initialized the break point entry in the IDT (i.e., your call to
===   SETGATE from idt_init). Why? How did you need to set it in
===   order to  get the breakpoint exception to work as specified
===   above and what incorrect setup would cause it to trigger a
===   general protection fault?
===   (free form)
To allow user to invoke int3 and generate a breakpoint exception, the DPL of 
the IDT entry for vector 3 needs to be set to 3 so that user-mode code (CPL=3)
can invoke it. If the DPL is 0 (kernel), then a user-mode int3 instruction will
trap as a general protection fault instead, because the privilege level is not
sufficient.

=== Q What do you think is the point of these mechanisms, particularly
===   in light of what the user/softint test program does? 
===   (free form, 1 sentence)
it provide controlled protection by allowing safe kernel entry points while
preventing unauthorized access.

=== Q In Exercise 9, what causes the page fault which panics the
===   kernel when running user/breakpoint?
===   (free form, 1 sentence)
it is caused by dereferencing pointer that is after user stack.
====================================================================
=== Q What challenge(s) have you chosen to implement? (specify
===   challenge numbers separated by spaces, if more than one)
1

=== Q If the challenge requires changing the kernel source, list the
===   files which you have changed/added during implementation.
===   (one file per line, relative to lab directory containing .git/)
kern/trapentry.S  
kern/trap.c

=== Q Describe you solution.
===   (free form, up to 500 words, don't need to use all 500!)
Hint: we implement a solution somewhat similar to what XV6 does.
In order to prevent code duplication between trapentry.S and trap.c, we
completed Challenge 1 by modifying the TRAPHANDLER macros to automatically
generate a table of addresses of trap handler functions that trap.c can use.
In trapentry.S, we expanded the TRAPHANDLER and TRAPHANDLER_NOEC macros to emit
.long entries into a .data section before each handler is declared in the .text
section. This way, whenever each handler is declared, its address is also 
stored in a successive data array.
We then established a symbol "handlers_func" to mark the beginning of this
handlers address array. It automatically maps every trap number to its
respective handler function, hence being consistent and free from boilerplate
code. In trap.c, we substituted the big list of separate function declarations
and SETGATE() calls with a single loop through this handlers_func array and 
properly sets up the IDT entries.
